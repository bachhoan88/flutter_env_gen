import 'package:code_builder/code_builder.dart';
import 'package:dart_style/dart_style.dart';

import '../annotations/env_gen.dart';
import 'env_parser.dart';

/// Generates Dart code from environment entries
class CodeGenerator {
  final Map<String, EnvEntry> entries;
  final EnvGen config;

  CodeGenerator({
    required this.entries,
    required this.config,
  });

  /// Generate the complete Dart file
  String generate() {
    final library = Library((b) => b
      ..comments.addAll([
        '// GENERATED CODE - DO NOT MODIFY BY HAND',
        '// Generated by flutter_env_gen',
        '',
        '// ignore_for_file: lines_longer_than_80_chars, constant_identifier_names',
      ])
      ..body.addAll([
        _generateEnvClass(),
        if (config.generateLoader) _generateLoaderClass(),
      ]));

    final emitter = DartEmitter(
      allocator: Allocator.simplePrefixing(),
      orderDirectives: true,
      useNullSafetySyntax: true,
    );

    final code = library.accept(emitter).toString();

    try {
      return DartFormatter().format(code);
    } catch (e) {
      // If formatting fails, return unformatted code
      return code;
    }
  }

  /// Generate the main environment class
  Class _generateEnvClass() {
    final className = config.className ?? 'Env';

    return Class((b) => b
      ..name = className
      ..docs.addAll([
        '/// Environment configuration',
        '/// Generated from: ${config.envFiles.join(', ')}',
      ])
      ..abstract = false
      ..fields.addAll(_generateFields())
      ..constructors.add(Constructor((b) => b
        ..constant = true
        ..name = '_'))
      ..methods.addAll([
        _generateCurrentEnvironmentGetter(),
        _generateInitMethod(),
        if (_hasSensitiveKeys()) _generateLoadSensitiveMethod(),
        if (_hasListFields()) _generateParseListMethod(),
      ]));
  }

  /// Generate fields from environment entries
  Iterable<Field> _generateFields() {
    return entries.entries.map((entry) {
      final fieldName = _transformFieldName(entry.key);
      final isRequired = config.requiredKeys.contains(entry.key);
      final isSensitive = _isSensitive(entry.key);

      final isList = entry.value.type == EnvType.list;

      return Field((b) => b
        ..name = fieldName
        ..type = Reference(entry.value.dartType)
        ..static = true
        ..modifier = (isSensitive || isList) ? FieldModifier.final$ : FieldModifier.constant
        ..docs.add('/// Environment variable: ${entry.key}')
        ..assignment = _generateFieldAssignment(entry.value, isRequired, isSensitive));
    });
  }

  /// Generate field assignment based on type and sensitivity
  Code _generateFieldAssignment(EnvEntry entry, bool isRequired, bool isSensitive) {
    if (isSensitive) {
      // For sensitive fields, use runtime loading
      return Code("_loadSensitive('${entry.key}')");
    }

    // For compile-time constants

    switch (entry.type) {
      case EnvType.boolean:
        return Code(
          "const bool.fromEnvironment('${entry.key}', defaultValue: ${entry.rawValue.toLowerCase()})",
        );
      case EnvType.integer:
        return Code(
          "const int.fromEnvironment('${entry.key}', defaultValue: ${entry.rawValue})",
        );
      case EnvType.string:
        return Code(
          "const String.fromEnvironment('${entry.key}', defaultValue: '${entry.rawValue}')",
        );
      case EnvType.double:
        // Double doesn't have fromEnvironment, so we use a workaround
        return Code(
          "double.parse(const String.fromEnvironment('${entry.key}', defaultValue: '${entry.rawValue}'))",
        );
      case EnvType.list:
        // List needs runtime parsing - can't use split in const context
        // Use late final instead
        return Code(
          "_parseList(const String.fromEnvironment('${entry.key}', defaultValue: '${entry.rawValue}'))",
        );
    }
  }

  /// Generate getter for current environment
  Method _generateCurrentEnvironmentGetter() {
    return Method((b) => b
      ..name = 'currentEnvironment'
      ..returns = const Reference('String')
      ..type = MethodType.getter
      ..static = true
      ..body = Code(
        "return const String.fromEnvironment('ENVIRONMENT', defaultValue: 'development');",
      ));
  }

  /// Generate initialization method for sensitive values
  Method _generateInitMethod() {
    return Method((b) => b
      ..name = 'init'
      ..returns = const Reference('void')
      ..static = true
      ..body = Code('''
    // Initialize sensitive values if needed
    // This method can be called at app startup
    '''));
  }

  /// Check if there are any sensitive keys
  bool _hasSensitiveKeys() {
    return entries.values.any((entry) =>
      config.sensitiveKeys.any((key) =>
        entry.key.toUpperCase().contains(key.toUpperCase())));
  }

  /// Generate method for loading sensitive values
  Method _generateLoadSensitiveMethod() {
    return Method((b) => b
      ..name = '_loadSensitive'
      ..returns = const Reference('String')
      ..static = true
      ..requiredParameters.add(Parameter((b) => b
        ..name = 'key'
        ..type = const Reference('String')))
      ..body = Code('''
    // This would typically load from a secure storage
    // For now, return empty string as we can't use key in const context
    return '';
    '''));
  }

  /// Check if there are any list fields
  bool _hasListFields() {
    return entries.values.any((entry) => entry.type == EnvType.list);
  }

  /// Generate helper method for parsing lists
  Method _generateParseListMethod() {
    return Method((b) => b
      ..name = '_parseList'
      ..returns = const Reference('List<String>')
      ..static = true
      ..requiredParameters.add(Parameter((b) => b
        ..name = 'value'
        ..type = const Reference('String')))
      ..body = Code('''
    return value.split(',');
    '''));
  }

  /// Generate loader class for runtime loading
  Class _generateLoaderClass() {
    return Class((b) => b
      ..name = '_EnvLoader'
      ..docs.add('/// Runtime loader for sensitive values')
      ..methods.add(Method((b) => b
        ..name = '_loadSensitive'
        ..returns = const Reference('String')
        ..static = true
        ..requiredParameters.add(Parameter((b) => b
          ..name = 'key'
          ..type = const Reference('String')))
        ..body = Code('''
    // This would typically load from a secure storage
    // For now, return empty string
    return '';
    '''))));
  }

  /// Transform field name based on configuration
  String _transformFieldName(String key) {
    switch (config.fieldRename) {
      case FieldRename.none:
        return key;
      case FieldRename.snakeToCamel:
        return _snakeToCamel(key);
      case FieldRename.snakeToPascal:
        return _snakeToPascal(key);
      case FieldRename.kebabToCamel:
        return _kebabToCamel(key);
    }
  }

  /// Convert SNAKE_CASE to camelCase
  String _snakeToCamel(String input) {
    final parts = input.toLowerCase().split('_');
    if (parts.isEmpty) return input;

    return parts.first +
        parts.skip(1).map((p) => p.isNotEmpty ? p[0].toUpperCase() + p.substring(1) : '').join();
  }

  /// Convert SNAKE_CASE to PascalCase
  String _snakeToPascal(String input) {
    final camel = _snakeToCamel(input);
    if (camel.isEmpty) return input;
    return camel[0].toUpperCase() + camel.substring(1);
  }

  /// Convert kebab-case to camelCase
  String _kebabToCamel(String input) {
    final parts = input.toLowerCase().split('-');
    if (parts.isEmpty) return input;

    return parts.first +
        parts.skip(1).map((p) => p.isNotEmpty ? p[0].toUpperCase() + p.substring(1) : '').join();
  }

  /// Check if a key is sensitive
  bool _isSensitive(String key) {
    final upperKey = key.toUpperCase();
    return config.sensitiveKeys.any(
      (pattern) => upperKey.contains(pattern.toUpperCase()),
    );
  }
}